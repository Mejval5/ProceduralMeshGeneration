#include "PrecomputedTables.hlsl"

#pragma kernel CSMain
#pragma target 5.0

// Define the main compute function
// Using AppendStructuredBuffer<int> for triangle indices
AppendStructuredBuffer<int3> AppendedTriangles;
RWStructuredBuffer<float3> SubVertices;
StructuredBuffer<float> BaseVerticesValues;
StructuredBuffer<int> CubeEdgeFlags;
StructuredBuffer<int> TriangleConnectionTable;

int4 VertexAmount; // w represents the cube floor
int4 CubeAmount; // w represents the cube floor
int2 Offsets; // x middle offset, y top offset
bool UseLerp;
float Threshold;

void GetMarchedCube(
    inout uint baseVerticesOffsets[8],
    inout int subVerticesOffsets[12],
    uint xPos,
    uint yPos,
    uint zPos)
{
    uint cubeIndex = 0u;
    for (uint index = 0u; index < CornersPerCube; index++)
    {
        float value = BaseVerticesValues[baseVerticesOffsets[index]];
        
        if (value > Threshold)
        {
            cubeIndex |= 1 << index;
        }
    }
    
    // Skip processing if cube is entirely inside or outside the surface
    if (cubeIndex == 0u || cubeIndex == 255)
    {
        return;
    }
    
    int cubeEdgeFlags = CubeEdgeFlags[cubeIndex];
    
    for (int edgeIndex = 0u; edgeIndex < EdgesPerCube; edgeIndex++)
    {
        uint startPointLocal = EdgeConnection[edgeIndex * EdgeConnectionTableRowSize + 0u];
        uint endPointLocal = EdgeConnection[edgeIndex * EdgeConnectionTableRowSize + 1u];
        
        uint startPoint = baseVerticesOffsets[startPointLocal];
        uint endPoint = baseVerticesOffsets[endPointLocal];
        
        float startValue = BaseVerticesValues[startPoint];
        float endValue = BaseVerticesValues[endPoint];
        
        bool hasCrossing = (cubeEdgeFlags & (1 << edgeIndex)) != 0;

        float offset = Threshold;
        if (UseLerp && hasCrossing)
        {
            offset = (Threshold - startValue) / (endValue - startValue);
        }
        
        int index = subVerticesOffsets[edgeIndex];
        
        float newX = EdgeDirection[edgeIndex * EdgeDirectionTableRowSize] * offset + CubeCornersPositions[startPointLocal * CubeCornersPositionsRowSize + 0u] + xPos;
        float newY = EdgeDirection[edgeIndex * EdgeDirectionTableRowSize + 1u] * offset + CubeCornersPositions[startPointLocal * CubeCornersPositionsRowSize + 1u] + yPos;
        float newZ = EdgeDirection[edgeIndex * EdgeDirectionTableRowSize + 2u] * offset + CubeCornersPositions[startPointLocal * CubeCornersPositionsRowSize + 2u] + zPos;
        SubVertices[index] = float3(newX, newY, newZ);
    }
    
    for (uint i = 0u; i < TriangleConnectionTableWidth;)
    {
        int vertexIndex = TriangleConnectionTable[cubeIndex * TriangleConnectionTableRowSize + i];
        if (vertexIndex == -1)
        {
            break;
        }

        int3 tri;
        for (int j = 0; j < 3; j++)
        {
            int winding;
            
            if (Threshold > 0)
            {
                winding = 2 - j;
            }
            else
            {
                winding = j;
            }

            // Calculate the local vertex index
            int localVertexIndex = TriangleConnectionTable[cubeIndex * TriangleConnectionTableRowSize + i + winding];
            
            // Assign values to the correct component of the int3
            if (j == 0)
            {
                tri.x = subVerticesOffsets[localVertexIndex];
            }
            else if (j == 1)
            {
                tri.y = subVerticesOffsets[localVertexIndex];
            }
            else if (j == 2)
            {
                tri.z = subVerticesOffsets[localVertexIndex];
            }
        }
        
        i += 3;
        AppendedTriangles.Append(tri);
    }
}


// Define the main compute function
[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;

    uint xIndex = index % CubeAmount.x;
    uint zIndex = (index % CubeAmount.w) / CubeAmount.x;
    uint yIndex = index / CubeAmount.w;

    if (xIndex >= (uint) CubeAmount.x || zIndex >= (uint) CubeAmount.y || yIndex >= (uint) CubeAmount.z)
    {
        return;
    }
    
    int indexOffset = xIndex + zIndex * (CubeAmount.x + VertexAmount.x) + yIndex * Offsets.y;
    int middleIndexOffset = Offsets.x - zIndex * CubeAmount.x;

    int subVerticesOffsets[12];
    // Front face
    subVerticesOffsets[0] = indexOffset;
    subVerticesOffsets[1] = indexOffset + middleIndexOffset + 1;
    subVerticesOffsets[2] = indexOffset + Offsets.y;
    subVerticesOffsets[3] = indexOffset + middleIndexOffset;

    // Back face
    subVerticesOffsets[4] = indexOffset + CubeAmount.x + VertexAmount.x;
    subVerticesOffsets[5] = indexOffset + middleIndexOffset + VertexAmount.x + 1;
    subVerticesOffsets[6] = indexOffset + Offsets.y + VertexAmount.x + CubeAmount.x;
    subVerticesOffsets[7] = indexOffset + middleIndexOffset + VertexAmount.x;
    
    // Middle face
    subVerticesOffsets[8] = indexOffset + CubeAmount.x;
    subVerticesOffsets[9] = indexOffset + CubeAmount.x + 1;
    subVerticesOffsets[10] = indexOffset + Offsets.y + CubeAmount.x + 1;
    subVerticesOffsets[11] = indexOffset + Offsets.y + CubeAmount.x;
    
    uint baseIndexOffset = xIndex + zIndex * VertexAmount.x + yIndex * VertexAmount.w;
    
    uint baseVerticesOffsets[8];
    // Front face
    baseVerticesOffsets[0] = baseIndexOffset;
    baseVerticesOffsets[1] = baseIndexOffset + 1;
    baseVerticesOffsets[2] = baseIndexOffset + VertexAmount.w + 1;
    baseVerticesOffsets[3] = baseIndexOffset + VertexAmount.w;

    // Back face
    baseVerticesOffsets[4] = baseIndexOffset + VertexAmount.x;
    baseVerticesOffsets[5] = baseIndexOffset + VertexAmount.x + 1;
    baseVerticesOffsets[6] = baseIndexOffset + VertexAmount.x + VertexAmount.w + 1;
    baseVerticesOffsets[7] = baseIndexOffset + VertexAmount.x + VertexAmount.w;

    GetMarchedCube(
    baseVerticesOffsets,
    subVerticesOffsets,
    xIndex,
    yIndex,
    zIndex);       
}

